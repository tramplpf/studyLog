# Java多线程相关知识

## 多线程入门

### 线程，进程以及协程的区别





### 为什么要是有多线程





### 多线程的创建方式

* 继承Thread类
* 实现Runable接口
* 实现Callable接口

Callable接口和Runable接口功能类似，但是Callable接口功能比Runable更强大

* Callable可以在任务结束的时候，提供一个返回值，Runable无法提供这个功能
* Callable 的call 方法可以抛出异常，而Runable的run方法不能抛出异常



### 线程中的异常处理

线程设计的理念： 线程的问题应该线程自己本身来解决，而不是要委托到外部。 



**方式一：**

在线程方法内，使用try-catch 包装所有的方法体

**方式二**

给某个thread设置一个UncaughtExceptionHandler，可以确保在该线程出现异常时能通过回调 UncaughtExceptionHandler 接口的public void uncaughtException(Thread t, Thowable e) 方法来处理异常，这样的好处是可以在线程代码边界之外(Thread的run() 方法之外) ，有一个地方能处理捕获异常。 

需要明确的是：虽然是在回调方法中处理异常，但这个回调方法在执行时依然孩子抛出异常的这个线程中。另外还要特别说明一点：如果线程是通过线程池创建，线程异常发生时UncaughtExceptionHandler 接口不一定会立即回调。





### 线程的分类

Java中有两种线程，一种是用户线程，另一种是守护线程。

 用户线程是指用户自定义创建的线程，主线程停止，用户线程不会停止

守护线程当进程不存在或主线程停止，守护线程也会被停止。

 使用setDaemon(true)方法设置为守护线程



### 线程的生命周期

* 新建

* 就绪

  * 线程调用start方法之后，就处于就绪状态

* 运行状态

  * 获取到CUP后就处于运行状态

* 阻塞状态

   线程运行过程中，可能由于各种原因进入阻塞状态

  * 线程通过调用sleep方法进入睡眠状态
  * 线程调用一个在I/O 上被阻塞的操作，即该操作在输入输出操作完成之前不会返回到它的调用者
  * 线程视图得到一个锁，而该锁正被其他线程持有
  * 线程在等待某个触发条件(不太明白)

* 死亡状态

  * run方法执行完之后，自然死亡
  * 一个未捕获的异常终止了run方法而使线程死亡

   为了确定线程在当前是否存活着（就是要么是可运行的，要么是被阻塞了），需要使用isAlive方法。如果是可运行或被阻塞，这个方法返回true； 如果线程仍旧是new状态且不是可运行的， 或者线程死亡了，则返回false.



### Thread类常用的方法

* join() 方法

  在很多情况下，都由主线程创建并运行子线程，如果子线程中需要大量的耗时操作，主线程往往早于子线程结束。如果主线程想要等待子线程完成后再执行。比如子线程处理一个数据运算，而主线程想要获取这个数据，可以用join方法。 

​		方法join() 的作用就是使属性的线程对象x(子线程) 执行run 方法中的任务，而使得当前线程z(主线程) 进行无限期的阻塞，等待线程x销毁后再继续执行z后面的代码。 





* yield() 方法



































