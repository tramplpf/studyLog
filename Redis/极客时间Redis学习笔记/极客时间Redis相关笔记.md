# 极客时间Redis核心技术与实战

## 开篇词


### 04 AOF日志，宕机了，Redis如何避免数据丢失


### 05 内存快照： 宕机后，Redis如何实现快速恢复
Redis在使用RDB进行持久化时，Redis会fork子进程来完成。 fork操作的用时和Redis的数据量是正相关的，而fork在执行时会阻塞主线程。 数据量越大，fork操作造成的主线程阻塞的时间越长。


### 06 数据同步：主从库如何实现数据一致
* 要解决的问题：
1. 在Redis单实例中，Redis服务宕机之后，Redis在恢复期间提供的服务是不可用的

Redis的高可靠性包括如下两点
* 数据尽量少丢失  
    AOF 和RDB 保证了数据尽量少丢失
* 服务尽量少中断      
    Reids 通过增加副本冗余量来保证服务尽量少中断

Redis部署多套实例可能存在的问题
1. 多副本之间数据如何保持一致?
2. 数据读写操作可以发给所有的实例吗?

Redis提供了主从库模式，以保证数据副本的一致，主从库之间采用的是读写分离的方式。 

* 读操作：主库，从库都可以接收
* 写操作：首先到主库执行，然后，主库将写操作同步给从库



主从库间数据第一次同步的三个阶段
* 第一阶段： 建立连接，协商同步
* 第二阶段： 主库同步数据给从库
* 第三阶段： 主库发送新的写命令给从库


主从级联模式分担全量复制是的主库压力
我们可以通过“主-从-从”模式将主库生成RDB和传输RDB的压力，以级联的方式分散到从库上。 
在部署主从集群的时候，可以手动选择一个从库（比如选择内存资源配置较高的从库），用于级联其他的从库。然后，我们可以再选择一些从库，让这些从库从所选择的从库建立起主从关系。 


一旦主从库完成了全量复制，它们之间就会一直维护一个网络连接，主库会通过这个连接将后续陆续接收到的命名操作再同步给从库，这个过程也称为**基于长链接的命令传播**，可以避免频繁建立连接的开销。 


主从库网络断了怎么办？

## 重要的参数
* repl_backlog_size 


## 总结
* Redis的主从库同步的基本原理，总结来说，有三种模式： 全量复制，基于长连接的命名传播，以及增量复制



## 新引入的问题
主从库模式使用读写分离虽然避免了同时写入实例带来的数据不一致问题，但是还面临主库故障的潜在风险。 

## 课后问题
为什么主从库间的复制不使用 AOF 呢？
个人理解： 主从库复制，使用RDB而不使用AOF 是因为使用AOF 的话，传输的数据量比较大，网络带宽消耗比较大，不利于高性能。 







## 思考
* 如何查看Redis缓存的数据占用了多少内存？
* 有什么命令，可以临时断开两个机器中间的网络连接？
* 


### 07哨兵机制：主库挂了，如何不间断服务

#### 疑惑
1. 在微服务中访问Redis集群的时候，如何确定该读取Redis集群中的哪个数据？
2. 在Redis集群中，Redis的主节点变更之后，重启集群项目，是不是需要调整Redis连接的相关信息了 ？
3. 

#### 知识点
在Redis主从集群中，哨兵机制是实现主从库自动切换的关键机制，它有效地解决了主从复制模式下故障转移的三个问题
1. 主库真的挂了吗？
2. 该选择哪个从库作为主库
3. 怎么把新主库的相关信息通知给从库和客户端


哨兵其实就是一个运行在特殊模式下的Redis进程，主从库实例运行的同时，它也在运行。 
哨兵主要负责的就是三个任务： 监控，选主（选主主库），和通知。 

* 监控
  * 监控就是指哨兵进程在运行时，周期性的给所有的主从库发送PING命令，检测她们是否仍然在线运行。 
* 选主
* 通知


#### 如何选定新主库
筛选条件
   查看从库之前的网络连接状态
打分条件
* 从库优先级    
  第一轮： 优先级最高的从库得分高
* 从库复制进度
  * 和旧主库同步程度最接近的从库得分最高
* 从库ID号
  * 每个实例都会有一个ID，这个ID 就类似于这里的从库的编号。 
  * Redis在选主库时，有一个默认的规定，在优先级和复制进度都相同的情况下，ID号最小的从库得分最高，会被选为新主库。
* 




#### 重要的参数
slave-priority ： 给不同的从库设置不同的优先级

master_repl_offset： 主库用来记录当前在最新写操作在repl_backlog_buffer 中的位置
slave_repl_offset：  从库用来记录当前的复制进度。

#### 总结
Redis的哨兵机制，是实现Redis不间断服务的重要保证。具体来说，主从集群的数据同步，是数据可靠的基础保证，而在主库发生故障时，自动的主从切换时服务不间断的关键支撑。 

### 08 哨兵集群：哨兵挂了，主从库还能切换吗？



### 09 切片集群： 数据增多了，是该加内存还是加实例？
#### 需要解决的问题
* Redis如何保存更多数据？
* 数据如何存储到redis cluster上的
* 客户端如何定位数据在哪个实例上？

##### 相关命令
* 使用info命令查看Redis的 latest_fork_usec 指标值（表示最近一次fork的耗时）
* redis cluster中的命令： 
  * cluster create 创建集群
  * cluster meet 命令手动建立实例间的连接，形成集群，
  * cluster addslots 命令，指定每个实例上的哈希槽的个数
    * 这个命令，针对不同Redis实例，内存容量不一样的情况。
* MOVED 命令 ： 可以定位某个哈希槽所在Redis实例的ip和端口。 
  * MOVED 命令会更该本地缓存，让后续所有命令都发往新实例。 
* ASK 命令：表示哈希槽正在迁移过程中，没有完全迁移完。
  * ASK 命令并不会更新客户端缓存的哈希槽分配信息。 
* ASKING 命令： 

在实际应用Redis时，随着用户或业务规模的扩展，保持大量数据的情况通常是无法避免的，而切片集群，就是一个非常好的解决方案。 

切片集群不可避免地涉及到多个实例的分布式管理问题。 要想把切片集群用起来，我们需要解决两大问题
* 数据切片后，在多个实例之间如何分布
  * 从3.0 开始，Redis官方提供了一个名为Redis Clluster的方案，用于实现切换集群。Redis Cluster中规定了数据和实例的对应规则。 
  * Redis cluster中一共有16384个哈希槽
  * 在手动分配哈希槽的时候，需要把16384个槽都分配完，否则Redis集群无法正常工作。 
* 客户端怎么确定想要访问的数据在哪个实例上？
* 

通过哈希槽，切片集群实现了数据懂啊哈希槽，哈希槽再到实例的分配。

#### 客户端如何定位数据在哪个实例上


在集群中，实例和哈希槽的对应关系并不是一成不变的，最常见的变化有两个
1. 在集群中，实例有新增或删除，Redis需要重新分配哈希槽
2. 为了负载均衡，Redis需要把哈希槽在所有实例上重新分布一遍。 
   飞：如果这样，手动设置的哈希槽位置，是不是就发生改变了？
  
Redis Cluster 方案提供了一种重定向机制，所谓的重定向，就是指，客户端给一个实例发送数据读写操作时，这个实例上并没有相应的数据，客户端要再给一个新实例发送操作命令。 



## 基础篇
## 实战篇

### 11 万金油的String为什么不好用了

String类型并不是实用与所有的场合，它有一个明显的短板，就是它保存数据时所消耗的内存空间比较多。

#### 要解决的问题
* 为什么String类型内存开销大？
* 




#### String类型内存开销为什么大？
除了记录实际数据，String类型还需要额外的内存空间记录数据长度，空间使用等信息，这些信息也叫做元数据。点那个实际保存的数据较小时，元数据的空间开心就显得比较大了，优点喧宾夺主的意思。 

***当你保存64位有符号整数时，String类型会把它保存位一个8字节的Long类型整数，这种保存方式通常也叫做int编码方式***
但是当你保存的数据中包含字符串时，String类型就会用简单动态字符串（Simple Dynamic String， SDS） 结构体来保存。

SDS：
    buf：字节数组
    len：占4个字节
    alloc： 占4个字节
对于String类型来说，除了SDS的额外开销，还有一个来自RedisObject结构体的开销。 
一个ReidsObject包含了8个字节的元数据和一个8字节的字节指针，这个指针再进一步指向具体数据类型的实际数据所在。






### 12 有一亿个keys要统计，应该用哪种集合

#### 集合类型常见的四种统计模式
* 聚合统计
  * 所谓的聚合统计，就是指统计多个集合元素的聚合结果，包括： 统计多个集合的共有元素（交集）；
  * 把两个集合相比，统计其中一个集合独有的元素（差集统计）
  * 统计多个集合的所有元素（并集统计）
  * 对应的案例： 统计手机App每天的新增用户数和第二天的留存用户数。
  * Set 集合的差集，并集和交集复杂度较高，在数据量较大的情况下，如果直接执行这些计算，会导致Reids实例阻塞。 建议：可以从主从集群中选择一个从库，让它专门负责聚合计算，或者是把数据读取到客户端，在客户端来完成聚合统计。 
* 排序统计
  * 场景： 电商网站提供最新评论列表的功能， 最新评论列表包含了所有评论中的最新留言。 
  * List是按照元素进入List的顺序进行排序饿的，而Sorted Set可以根据元素的权重来排序，我们可以自己决定每个元素的权重值。
* 二值统计
  * 场景：签到打卡的场景
  * 二值状态就是指集合元素的取值就只有0和1 两种，在签到打卡的场景中，我们只用记录签到（1）或者未签到（0），是典型的非常典型的二值状态。 
  * Bitmap本身是用String类型作为底层数据结构实现的一种统计二值状态的数据类型。 
* 基数统计
  * 场景：基数统计就是指统计一个集合中不重复元素的个数，对应到我们的场景，就是统计网页的UV。 
  * HyperLogLog 是一种用于统计基数的数据集合类型，他的最大优势在于，当集合元素数量非常多时，它计算基数所需的空间总是固定的，而且还很小。 
  * 在Redis中，每个HyperLogLog 只需要花费12kb内存，就可以计算接近2^64个元素的基数。
  * 你可以用 PFADD 命令（用于向 HyperLogLog 中添加新元素）把访问页面的每个用户都添加到 HyperLogLog 中。
  * 接下来，就可以用 PFCOUNT 命令直接获得 page1 的 UV 值了，这个命令的作用就是返回 HyperLogLog 的统计结果
  * HyperLogLog 的统计规则是基于概率完成的，所以它给出的统计结果是有一定误差的，标准误算率是 0.81%。这也就意味着，你使用 HyperLogLog 统计的 UV 是 100 万，但实际的 UV 可能是 101 万。虽然误差率不算大，但是，如果你需要精确统计结果的话，最好还是继续用 Set 或 Hash 类型
  * 
* 



### 13 GEO时什么？ 还可以定义新的数据类型吗？
#### 问题
* 介绍开发自定义的新数据类型的基本步骤
* 扩展数据类型 GEO 的实现原理和使用方法
* LBS：基于位置信息服务  （Location-Based Service， LBS ）

飞： 感觉和自己关系不大，暂时不学习这一章节内容



### 14 如何在Redis中保存时间序列数据？
### 15 消息队列的考验：Redis有哪些解决方案
### 16 异步机制： 如何避免单线程模型的阻塞？
学习日期： 2022-11-06 星期日

#### 影响Redis性能的5大方面的潜在因素
* Redis 内部的阻塞式操作
* CPU 核核NUMA架构的影响
* Redus关键系统配置
* Redis内存碎片
* Redis缓冲区 



Redis内部阻塞操作的5类操作。 
Redis的5大交互对象。 




### 17 为什么CPU结构也会影响Redis的性能？

我们学习一下目前主流服务器的CPU架构，以及基于CPU多核架构和多CPU架构优化Redis性能的方法。 

我们可以使用 taskset 命令把一个程序绑定在一个核上运行。


### 18 波动的响应延迟： 如何应对慢的Redis？（上）

#### 判断Redis的响应是否变慢
* 查看Redis的响应延迟
  * redis-cli --latency -h host -p port 查看相应延迟
* 基于当前环境下的Redis基线性能做判断
  * 所谓的基线性能，就是一个系统在低压力，无干扰下的基本性能，这个性能只能由当前的软硬件配置决定
  * redis-cli --intrinsic-latency 可以用来检测和统计测试期间内的最大延迟，这个延迟可以作为Redis的基线性能。其中，测试时长可以用--intrinsic-latency 选项的参数来指定
  * redis-cli --intrinsic-latency 120  可以查看redis在120秒内的基线延迟
  * 基线性能和当前的操作系统，硬件配置相关。因此，我们可以把它和Redis运行时的延迟结合起来，再进一步判断Redis性能是否变慢
  * 如果观察到的Redis运行时的延迟时其基线性能的2倍以上，就可以认定Redis变慢了
  * 查看基线性能，应该在服务器端执行该命令，来避免网络对基线的性能影响
* 如果你想了解网络对 Redis 性能的影响，一个简单的方法是用 iPerf 这样的工具，测量从 Redis 客户端到服务器端的网络延迟。如果这个延迟有几十毫秒甚至是几百毫秒，就说明，Redis 运行的网络环境中很可能有大流量的其他应用程序在运行，导致网络拥塞了。这个时候，你就需要协调网络运维，调整网络的流量分配了

#### 如何应对Redis变慢？
在诊断Reids变慢这个病症时，你要基于自己对Redis本身的工作原理的理解，并且结合和它交互的操作系统，存储以及网络等外部系统关键机制，再借助一些辅助工具来定位原因，并制定行之有效的解决方案。 

* Redis 自身的操作特性，文件系统和操作系统，它们时影响Redis性能的三大要素。 

#### Redis自身操作特性对Redis变慢的影响
* 慢查询命令
  * 查看Redis所有命令的介绍 https://redis.io/commands/
  * 可以通过Redis日志或者latency monitor 工具，查询变慢的请求
  * 解决方法一：使用其他高效的命令代替。 例如使用ssscan 多次迭代返回数据，而不是使用smemners 命令
  * 解决方法二：当需要进行排序，交集，并集操作的时候，可以在客户端完成，而不要用sort，sunnion，sinter 这些命令，避免拖慢Redis实例
  * 注意： keys命令需要遍历存储的健值对，所以操作延时高。 所以，keys命令一般不被建议用于生产环境中。 
* 过期key操作
  * 过期key的自动删除机制。它是Redis用来回收内存空间的常用机制，应用广泛，本身就会引起Redis的操作阻塞，导致性能变慢。
  * Redis 键值对的 key 可以设置过期时间。默认情况下，Redis 每 100 毫秒会删除一些过期 key，
  * 具体的算法如下：采样 ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP 个数的 key，并将其中过期的 key 全部删除；
  * 如果超过 25% 的 key 过期了，则重复删除的过程，直到过期 key 的比例降至 25% 以下。

要真正把Redis用好，除来要了解Redis本身的原理，还要了解和Redis交互的各底层系统的关键机制，包括操作系统和文件系统。 
通常情况下，一些难以排查的问题是Redis的用法或设置和底层系统的工作机制不协调导致的。 


### 19 波动的响应延迟：如何应对满的Redis（下）
### 20 删除数据后，为什么内存占用率还是很高？
### 21 缓冲区：一个可能引发惨案的地方

#### 输入缓冲区
1. 引起输入缓冲区溢出的原因
*  写入了bigkey
*  服务器处理请求的速度过慢，例如Reids主线程出现了间歇性阻塞，无法及时处理正常发送的请求，导致客户端发送的请求在缓冲区越积越多

2. 查看输入缓冲区内存使用情况
* CLIENT LIST 命令
* 查看和服务器端相连的每个客户端对输入缓冲区的使用情况。
* 返回结果中，与输入缓冲区相关的参数
  * cmd 表示客户端 最新执行的命令
  * qbuf 表示输入缓冲区已经使用的大小
  * qbuf-free 表示输入缓冲区尚未使用的大小
* 
#### 输出缓冲区
1. 输出缓冲区溢出的情况
* 服务器端返回bigkey的大量结果
* 执行了MONITOR命令
* 缓冲区大小设置的不合理

MONITOR命令是用来监控Redis行为的。 执行这个命令之后，就会持续输出检测到的各个命令操作。 

输入缓冲区默认是1G，且不可修改。但是输出缓冲区可以通过 client-output-buffer-limit 配置项，来设置缓冲区的大小。 





### 22: 11-21讲课后思考答案


### 23 旁路缓存：Redis是如何工作的？

系统的掌握缓存的一系列内容，包括工作原理，替换策略，异常处理和扩展机制。 具体来说，我们需要解决四个关键问题
* Redis缓存具体是怎么工作的？
* Redis缓存如果满了，该怎么半？
* 为什么会有缓存一致性，缓存穿透，缓存雪崩，缓存击穿等异常，该如何应对？
* Redis的内存毕竟有限，如果用快速的固态硬盘来保存数据，可以增加缓存的数据量，那么Redis缓存可以使用快速固态硬盘吗？
  

计算机系统中不同层之间的访问速度不一样，所以我们才需要缓存。 

缓存中的数据需要按照一定规则淘汰出去，写会后端系统，而新的数据又要从后段系统中读取进来，写入缓存。 

Redis本身是支持按照一定规则淘汰数据的，相当于实现了缓存的数据淘汰，其实，这也是Redis适合用作缓存的一个重要原因。 

#### Redis缓存是如何处理请求的/Redis缓存处理请求的两种情况
* 缓存命中
  * Redis中有相应的数据，就直接读取Redis，性能非常快
* 缓存缺失
  * 一旦发生缓存缺失，为了让后续请求能从缓存中读取到数据，我们需要把缺失的数据写入Redis，这个过程叫做缓存更新。 
  * 缓存更新操作会涉及到爆炸缓存和数据库之间的数据一致性问题。 
  

<img src="./pic/01_Redis缓存读取两种情况_V20221114.webp">
飞： 看到上面Redis缓存中的图，突然意识到Java只是一个实现某些业务逻辑的语言而已，在一个系统中，是通过某种语言来实现对某些数据库（Redis/Mysql） 的访问（读/写）。 在画部署图/架构图的时候，要体现出这些数据库之间的关系。可以试着将语言剥离出区。 通过简单的箭头来说明语言要实现的业务逻辑。 
上图中，说明了一件事，Redis 需要位于Mysql数据库前面。 为数据库避免流量洪峰起到一定的保护作用，同时Redsi作为缓存，提升了整个系统的性能。 


#### Redis作为旁路缓存的使用操作
Redis 是一个独立的系统软件，和业务应用程序是两个软件，当我们部署了 Redis 实例后，它只会被动地等待客户端发送请求，然后再进行处理。所以，如果应用程序想要使用 Redis 缓存，我们就要在程序中增加相应的缓存操作代码。所以，我们也把 Redis 称为旁路缓存，也就是说，读取缓存、读取数据库和更新缓存的操作都需要在应用程序中来完成。

这和我刚才讲的计算机系统中的 LLC 和 page cache 不一样。你可以回想下，平时在开发程序时，我们是没有专门在代码中显式地创建 LLC 或 page cache 的实例的，也没有显式调用过它们的 GET 接口。这是因为，我们在构建计算机硬件系统时，已经把 LLC 和 page cache 放在了应用程序的数据访问路径上，应用程序访问数据时直接就能用上缓存。


按照Redis缓存是否接受写请求，我们可以把它分为只读缓存和读写缓存。 
* 只读缓存
* 读写缓存
  * 根据业务应用对数据可靠性和缓存性能的不同要求，我们会有同步直写和异步写回两种策略。其中同步直写策略优先保证数据可靠性，而异步写会策略优先提供快速响应。

我们学习了缓存的两个特征，分别是在分层系统中，数据暂存在快速子系统中有助于加速访问；缓存容量有限，缓存写满时，数据需要被淘汰。而Redis天然就具有高性能访问和数据淘汰机制，
正好符合缓存的这两个特征的要求。 

Redis的旁路缓存的特性，旁路缓存就意味着需要在应用程序中新增缓存处理逻辑的代码。 
在无法修改源码的场景，就不能使用Redis做缓存。 


#### 替换策略：缓存满了怎么办？
缓存系统的重要机制--缓存数据的淘汰机制。

##### 缓存容量的设置
20%的数据不一定能贡献80%的访问量，我们不能简单地按照总数量的20%来设置缓存最大空间容量。 **系统的设计选择时一个权衡的过程**：大容量缓存时能带来性能加速的收益，但是成本也会更高，
而小容量缓存不一定就起不到加速访问的效果。 

对于Redis来说，一旦确定了缓存最大容量，可以使用如下这个命令来设定缓存的大小：
```shell
    CONFIG SET maxmemory 4gb
```

* 缓存的替换要解决两个问题
  * 决定淘汰哪些数据
  * 如何处理哪些被淘汰的数据
  
* Redis缓存的淘汰策略
  * Redis 4.0 之前的6种内存淘汰策略以及Redis 4.0之后新增的2种策略

<img src="./pic/02_Redis内存淘汰策略_V20221116.webp">


* volatile-ttl 在筛选时，会针对设置了过期时间的键值对，根据过期时间的先后进行删除，越早过期的越先被删除。
* volatile-random 就像它的名称一样，在设置了过期时间的键值对中，进行随机删除。
* volatile-lru 会使用 LRU 算法筛选设置了过期时间的键值对。
* volatile-lfu 会使用 LFU 算法选择设置了过期时间的键值对

相对于volatile-ttl， volatile-random， volatile-lru， volatile-lfu 这四种淘汰的是设置了过期时间的数据。 
allkeys-lru，allkeys-random， allkeys-lfu 这三种淘汰策略的备选淘汰数据的范围，就扩大大了所有的件值对，无论这些键值对是否设置了过去时间。 

* allkeys-random 策略，从所有键值对中随机选择并删除数据；
* allkeys-lru 策略，使用 LRU 算法在所有数据中进行筛选。
* allkeys-lfu 策略，使用 LFU 算法在所有数据中进行筛选。

在 allkeys 的三种淘汰策略种，如果一个键值对被删除策略选中了，即使它的过去时间还没到，也需要被删除。 当然，如果它的过期时间到了，但未被策略选中，同样也会被删除。 


#### LRU算法
LRU 算法全称是 Least Recentyl Used。 按照最近最少使用的原则来筛选数据，最不常用的数据会被筛选出啦，而最近频繁使用的数据会被留在缓存中。 

LRU算法的底层是一个链表。 
在Redis中，LRU算法被做了简化，以减轻数据淘汰对缓存性能的影响。Redis默认回记录每个数据的最近异常访问的时间戳（由简直对数据结构RedisObject中的lru字段记录），然后，Redis在决定淘汰数据的时候，第一次回随机选出N个数据，把他作为一个候选集合，接下来，Redis会比较这N个数据的lru自动，把lru自动值最小的数据从缓存中淘汰出去。 


Redis提供了一个配置参数maxmemory-samples，这个参数就是Redis选出的数据个数N。 
```
  CONFIG SET maxmemory-samples 100 
```

#### 如何处理被淘汰的数据？
一般来说，一旦被淘汰的数据选定后，如果这个数据是感觉数据，那么我们就直接删除；如果这个数据是脏数据，我们需要把它写会数据库。 

对于Redis来说，它决定了被淘汰的数据后，会把它门删除，即使淘汰的数据是脏数据，Redis也不会把她们写回数据库，所以，我们在使用Redis缓存时，如果数据被修改了，需要在数据修改时将数据写回数据库。否则，这个脏数据在被淘汰时，会被Redis删除，而数据库里也没有最新的数据。 


### 25 缓存异常（上）： 如何解决缓存和数据库的不一致问题
在实际应用Redis缓存时，我们经常会遇到一些异常问题，概括来说有4个方面：
* 缓存中的数据和数据库中的不一致；
* 缓存雪崩
* 缓存击穿
* 缓存穿透

##### 缓存和数据库的数据不一致是如何发生的？
数据的一致性，包括了两种情况
* 缓存中有数据，那么缓存的数据值需要和数据库中的值相同
* 缓存中本身没有数据，那么数据库中的值比心时最新值。 




在更新数据库和删除缓存值的过程中，无论这两个操作的执行顺序谁先谁后，只要有一个操作失败了，就会导致客户端端读取到旧值。
<img src="./pic/03_不同顺序更新数据库和Redis缓存数据都可能造成缓存不一致.webp">

#### 如何解决数据不一致问题？
* 方法一： 重试机制
具体来说，可以把要删除的缓存值或者是要更新的数据库值暂存到消息队列中（例如使用 Kafka 消息队列）。当应用没有能够成功地删除缓存值或者是更新数据库值时，可以从消息队列中重新读取这些值，然后再次进行删除或更新。如果能够成功地删除或更新，我们就要把这些值从消息队列中去除，以免重复操作，此时，我们也可以保证数据库和缓存的数据一致了。否则的话，我们还需要再次进行重试。如果重试超过的一定次数，还是没有成功，我们就需要向业务层发送报错信息了


* 情况一： 先删除缓存，再更新数据库
  在多线程情况下，可能存在数据不一致的情况
  <img src="./pic/04_先删除缓存再更新数据库可能存在的问题.webp">
  解决方案： 在线程A更新完数据库值以后，我们可以让它先sleep一小段时间，再进行一次缓存删除操作。 （延迟双删）
  之所以要加上 sleep 的这段时间，就是为了让线程 B 能够先从数据库读取数据，再把缺失的数据写入缓存，然后，线程 A 再进行删除。所以，线程 A sleep 的时间，就需要大于线程 B 读取数据再写入缓存的时间。
* 情况二： 先更新数据库值，再删除缓存值
  
### 26 缓存异常（下）：如何解决缓存和数据库的数据不一致问题？

下面是自己凭借知识积累总结的：
* 缓存雪崩
  * 问题描述：同一时间，有大量的缓存失效，这时，有大量的请求过来，在Redis缓存层没用找到数据，将请求全部转发到数据库，导致数据库压力过大。 可能导致数据库死机。 
  * 解决方案：为redis的key设置过期时间的时候，添加一个随机时间，避免缓存同一时刻大量失效。 
* 缓存击穿
  * 问题描述：请求访问的数据不存在这种情况下，缓存中，没有数据，每次请求都会在访问完请求之后，再次访问一下数据库
  * 解决方案：对于不存在的数据，在缓存中，设置一个特殊的值，表示该值在数据库中不存在
* 缓存穿透
  * 问题描述：
  * 解决方案：

下面是课程中描述的：
* 缓存雪崩
  * 表现：缓存雪崩是指大量的应用请求无法在 Redis 缓存中进行处理，紧接着，应用将大量请求发送到数据库层，导致数据库层的压力激增。
  * 诱发原因：
    * 原因1: 缓存中有大量数据同时过期，导致大量请求无法得到处理
    * 原因2: Redis缓存实例发生故障宕机了，无法处理请求，这就会导致大量请求一下子积压到数据库层，从而发生缓存雪崩。 
  * 解决方法：
    * 基于原因1的解决方案1：我们可以避免给大量的数据设置相同的过期时间。如果业务层的确要求有些数据同时失效，捏开使用expire命令给每个数据设置过期时间时，给这些数据的过期时间增加一个较小的随机数（例如随机增加1到3分钟），这样，不同数据的过去时间有所差别，但差别又不会太大。既避免了大量数据同时过期，同时也保证了这些数据基本在相近的时间失效，仍然能满足业务需求。 
    * 基于原因1的解决方案2: 通过服务降级来应对缓存雪崩。 所谓的服务降级，是指发生缓存雪崩时，针对不同的数据采取不同的处理方式。 
    * 基于原因二的解决方案： 在业务系统中失效服务熔断或请求限流机制。 
      * 所谓的服务熔断，是指在发生缓存雪崩的时候，为了防止引发连锁的数据库雪崩，甚至是整个系统的崩溃，我们暂停业务应用对缓存系统的接口访问。再具体点说，就是业务应用调用缓存接口时，缓存
        客户端并不把请求发给Redis缓存实例，而是直接返回，等到Redis缓存实例重新恢复服务后，再允许应用请求发送到缓存系统。 
      * 使用服务熔断或是请求限流机制，来应对Redis实例宕机导致的缓存雪崩问题，是属于“事后诸葛亮”，也就是已经发生了缓存雪崩，我们使用这两个机制，来降低雪崩对数据库和整个业务系统的影响。 
    * 基于原因二的解决方案2: 事前预防。 通过主从节点方式构建Redis 缓存高可靠集群。 如果Redis缓存的主节点故障宕机了，从节点还可以切换成主节点，继续提供缓存服务，避免了由于缓存实例宕机而导致的缓存雪崩问题。 
* 缓存击穿
  * 表现：缓存击穿是指，针对某个访问非常频繁的热点数据的请求，无法再缓存中进行处理，紧接着，访问该数据的大量请求，一下子都发送到了后端数据库，导致数据库压力激增。会影响数据库处理其他请求。
  * 缓存击穿的情况，经常发生在热点数据过期失效时。 
  * 解决方案：对于访问特别频繁的热点数据，我们不设置过期时间。 
* 缓存穿透
  * 表现：缓存穿透是指要访问的数据既不再Redis缓存中，也不在数据库中，导致请求在访问缓存时，发生缓存缺失，再去访问数据库时，发现数据库中也没有要访问的数据。 
  * 出现的原因： 
    * 1. 业务层误操作： 缓存中的数据和数据库中的数据被误删除，所以缓存和数据库中都没有数据
    * 2. 恶意攻击： 专门访问数据库中没有的数据
  * 解决方案：
    * 1. 缓存空值或缺省值: 一旦发生缓存穿透，我们可以针对查询的数据，在Redis中缓存一个空值或业务层协商确定的缺省值。 
    * 2. 使用布隆过滤器快速判断数据是否存在，避免从数据库中查询数据是哦福存在，减轻数据库压力
    * 3. 在请求入口的前端进行请求检测。  在请求入口前端，对业务系统接收到的请求进行合法性检测，把恶意的请求直接过滤掉，不让她们访问后台缓存和数据库。 

<img src="./pic/05_Redis缓存雪崩缓存击穿缓存穿透问题的解决方案.webp">


一般来说，一个Redis实例可以支持数万级别的请求处理吞吐量，而耽搁数据库可能只能支持数千级别的请求处理吞吐量。她们两个的处理能里可能相差了近十倍。由于缓存雪崩，Redis缓存失效，所以，数据库就可能要承受近十倍的请求压力，从而因为压力过大而崩溃。 


### 27 缓存被污染了，该怎么办？
#### 什么叫缓存污染
在一些场景下，有些数据被访问的次数非常少，甚至只会被访问一次，当这些数据服务完访问请求后，如果还继续留存在缓存中的话，就只会白白占用缓存空间。 这种情况就是缓存污染。 

#### 如何解决缓存污染问题

飞：感觉这里基于的场景是存在一个缓存系统，所有访问数据库的操作，都会先访问redis缓存系统，然后根据实际返回结果决定是否访问数据库以及是否更新redis缓存系统。 而不是根据具体的业务来决定是否要走缓存系统，还是直接查询数据库就行。  （因为这里提到了一张扫描式单次查询操作）
LFU淘汰策略会从两个维度筛选并淘汰数据：一是，数据访问的时效性（访问时间离当前时间的远近）；二是，数据的被访问次数。 

#### LFU缓存策略的优化
LFU 缓存策略是在 LRU 策略基础上，为每个数据增加了一个计数器，来统计这个数据的访问次数。当使用 LFU 策略筛选淘汰数据时，首先会根据数据的访问次数进行筛选，把访问次数最低的数据淘汰出缓存。如果两个数据的访问次数相同，LFU 策略再比较这两个数据的访问时效性，把距离上一次访问时间更久的数据淘汰出缓存。

TODO LFU 算法还需要再深入了解一下，目前了解的不够多。 


### 28 Pika： 如何基于SSD实现大容量Redis？

#### 29 无锁的原子操作： Redis如何应对并发访问
为了保证并发访问的正确性，Redis提供了两种方法，分别是加锁和原子操作。 

加锁会导致系统并发性能降低。 
和加锁类似，原子操作也能实现并发控制，但是原子操作对系统并发性能的影响较小，接下来，
我们就来了解Redis中的原子操作。 

* Redis的两种原子操作方法
  为了实现并发控制要求的临界区代码互斥执行，Redis的原子操作采用了两种方法：
  *  把多个操作在Redis中实现成一个操作，也就是单命令操作
  *  把多个操作写到一个Lua脚本中，以原子性方式执行单个Lua脚本
  
Redis提供的INCR/DESC命令可以对数据进行增值/减值操作，而且她们本身就是单个命令操作，
Redis在执行她们的时候，本身就具有互斥性。 


实现功能： 限制某个客户端在一定时间范围内的访问次数，比如爆款商品的购买限流，社交网站中每分钟点赞次数限制等。 
解决方案： 我们可以把客户端IP作为key，把客户端的访问次数作为value，保存到Reids中。 客户端每访问一次后，我们就用INCR增加访问次数。 
    注意：需要在一定时间内，第一次访问的时候，给该key值设置过期时间。 


//TODO lua 脚本编写
在一个lua脚本中，执行如下操作
1. 访问次数加1
2. 判断访问次数是否为1
3. 设置过期时间 
   将这个三个操作，通过lua脚本，来原子的执行。 

#### 30 如何使用Redis实现分布式锁
在分布式系统中，当有多个客户端需要获取锁时，我们需要分布式锁。此时，锁时保存在一个共享存储系统中的，可以被多个客户端共享访问和获取。 

##### 单机上锁和分布式锁的联系与区别
和单机上的锁类似，分布式锁同样可以用一个变量来实现。客户端加锁和释放锁的操作逻辑，也和单机傻姑娘的加锁和释放锁的逻辑一致：加锁时需要判断锁变量的值，根据锁变量值来判断能否枷锁成功；释放锁时需要把锁变量值设置为0，表明客户端不再持有锁。 


##### 基于单个Redis节点实现分布式锁

##### 基于多个Redis节点实现分布式锁





## 未来篇

## 加餐篇
### 加餐一： 经典的Redis学习资料有哪些
工具书： 《Redis使用手册》
       如果你想要了解最全，最新的Redis命令操作，建议把Redis的命令参考网站收录到你的浏览器书签中，随用随查。 
       https://redis.io/commands/
       http://redisdoc.com/  翻译版的Redis手册
原理书： 《Redis设计与实现》
       这本书讲解得非常透彻，尤其是在 Redis 底层数据结构、RDB 和 AOF 持久化机制，以及哨兵机制和切片集群的介绍上，非常容易理解，我建议你重点学习下这些部分的内容
实战书： 《Redis开发与运维》
      介绍了 Redis 的 Java 和 Python 客户端，以及 Redis 用于缓存设计的关键技术和注意事项，这些内容在其他参考书中不太常见，你可以重点学习下

Redis源码阅读： https://github.com/redis/redis.git   
            https://github.com/huangz1990/redis-3.0-annotated   有注释，基于Redis3.0 

Redis 的很多关键功能，其实和操作系统底层的实现机制是相关的，比如说，非阻塞的网络框架、RDB 生成和 AOF 重写时涉及到的 fork 和写时复制机制，等等。另外，Redis 主从集群中的哨兵机制，以及切片集群的数据分布还涉及到一些分布式系统的内容。

<img src="./pic/06_Redis 的关键机制和操作系统分布式系统的对应知识点.webp">


## Redis可以解决的业务问题
* 在移动应用中，需要统计每天的新增用户数和第二天的留存用户数
* 载电商网站的商品评论中，需要统计评论列表中的最新评论
* 在签到打卡中，需要统计一个月内连续打卡的用户数
  * 如果记录了1亿个用户10天的签到情况，你有办法统计出这10天连续签到的用户总数吗？
* 载网页访问记录中，需要统计独立博客访客量（unique Visitor， UV）。
